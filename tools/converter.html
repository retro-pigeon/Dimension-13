<!--- Takes a obj and converts it to a more readable format. Make sure model is triangulated --->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        function objtodad(obj) {
            let lines = obj.split('\n');
            let output = '';

            for (let line of lines) {
                const split = line.split(' ')
                let instruction = split[0];
                split.shift()
                let data = split.join(' ');

                if (instruction == 'v') {
                    output += data.split(' ').join(',');
                }

                if (instruction == 'f') {
                    if (output.indexOf(':') == -1)
                        output += ':';
                    output += data.split(' ').map(input => input.split('/')[0]).join(',') + ';';
                }
            }
            return output;
        }

        function bintogeometry(obj) {
            const verts = stringToCharCodeArray(obj.split('ÿ')[0]); //charcode 255
            const indices = stringToCharCodeArray(obj.split('ÿ')[1]).map(str => str * 254); //multiply by 254 for indices

            return { verts, indices };
        }

        const convert = value => (value + 127.5) / 255;

        function objtobin(obj) {
            let lines = obj.split('\n');
            let output = '';
            let colors = [];

            for (let line of lines) {
                const split = line.split(' ')
                let instruction = split[0];
                let currentColor = '#ff0000';
                split.shift()
                let data = split.join(' ');

                if (instruction == 'v') {
                    output += data.split(' ').map(s => String.fromCharCode(+s * 256 + 128).replace('\\', '\\\\').replace('\0', '\\0')).join``;
                }

                if (instruction == 'f') {
                    if (output.indexOf('ÿ') == -1)
                        output += 'ÿ';
                    output += data.split(' ').map(input => String.fromCharCode(+(input.split('/')[0])).replace('\\', '\\\\').replace('\0', '\\0')).join(``);
                    output += String.fromCharCode(colors.length - 1);
                }

                if (instruction == 'usemtl') {
                    color = data;
                    colors.push(color);
                }
            }
            console.log(colors);
            return output + 'ÿ' + colors.join``;
        }

        function hexToRgbArray(hex) {
            // Remove the "#" symbol if it exists
            hex = hex.replace(/^#/, '');

            // Parse the hex values for red, green, and blue
            const r = parseInt(hex.slice(0, 2), 16) / 255;
            const g = parseInt(hex.slice(2, 4), 16) / 255;
            const b = parseInt(hex.slice(4, 6), 16) / 255;

            // Return the RGB color as an array with values in the [0, 1] range
            return [r, g, b];
        }

        function parseOBJ(objString) {
            const parsedObjects = {};
            let currentObject = null;
            let currentColor = '#deadbeef';
            let currentColorCount = 0;
            let indexOffset = 0;

            const lines = objString.split('\n');

            for (let line of lines) {
                const parts = line.trim().split(/\s+/);

                if (parts[0] === 'o' && parts[1]) {
                    // Start of a new object
                    if (currentObject !== null) {
                        // If there's data in the current object, push it to the array
                        indexOffset += currentObject.data.vertices.length / 3;
                        parsedObjects[currentObject.name] = currentObject.data;
                    }
                    // Create a new object with an empty data object
                    currentObject = { name: parts[1], data: { vertices: [], normals: [], indices: [], colors: [] } };
                } else if (parts[0] === 'v') {
                    // Vertex
                    currentObject.data.vertices.push(Math.trunc(parseFloat(parts[1]) * 100), Math.trunc(parseFloat(parts[2]) * 100), Math.trunc(parseFloat(parts[3]) * 100));
                }
                else if (parts[0] === 'f') {
                    // Face
                    for (let i = 1; i < 4; i++) {
                        const faceData = parts[i].split('/');
                        currentObject.data.indices.push(parseInt(faceData[0]) - 1 - indexOffset); // OBJ indices start from 1!

                    }
                    currentColorCount++;
                } else if (parts[0] === 'usemtl') {
                    if (currentColorCount != 0)
                        currentObject.data.colors.push([currentColor, currentColorCount]);
                    currentColor = parts[1];
                    currentColorCount = 0;
                } 
            }

            if (currentColorCount != 0)
                    currentObject.data.colors.push([currentColor, currentColorCount]);

            if (currentObject !== null) {
                indexOffset += currentObject.data.vertices.length / 3;
                parsedObjects[currentObject.name] = currentObject.data;
            }

            return parsedObjects;
        }


        // Example usage:
        // const objString = '...'; // Your OBJ file content as a string
        // const { vertices, normals, indices } = parseOBJ(objString);


        const stringToCharCodeArray = s => [...s].map(c => c.charCodeAt() / 254);//note that it returns values between 0 and 1
        const charCodeArrayToString = a => a.map(i => String.fromCharCode(i * 254 | 0)).join``;

        console.log(stringToCharCodeArray(charCodeArrayToString([.3, .5, .8, .9])))

        function downloadFile(content, fileName, contentType) {
            const blob = new Blob([content], { type: contentType });
            const url = URL.createObjectURL(blob);

            const a = document.createElement("a");
            a.href = url;
            a.download = fileName;
            a.click();

            URL.revokeObjectURL(url);
        }


        // Example usage:
        // const plyString = '...'; // Your PLY file content as a string
        // const { vertices, normals, colors, indices, vertexFormat } = parsePLY(plyString);


        console.log(JSON.stringify(parseOBJ(`# Blender 4.2.0
# www.blender.org
mtllib ray.mtl
o Plane
o Cylinder
v -0.922805 -0.021015 -0.384694
v 0.128248 1.978985 0.991519
v -0.832544 0.021015 -0.553560
v -0.063125 2.021015 0.997784
v -0.218606 1.645652 0.975587
v -0.539093 1.312318 0.841984
v -0.794557 0.978985 0.606826
v -0.954186 0.645652 0.298475
v -0.998726 0.312319 -0.045876
v -0.400581 1.687681 0.916020
v -0.689720 1.354348 0.723771
v -0.895669 1.021015 0.444224
v -0.993587 0.687681 0.111097
v -0.971664 0.354348 -0.235430
vn -0.2965 0.0665 0.9527
vn -0.8868 0.0665 -0.4574
vn -0.9897 0.0665 -0.1266
vn -0.9733 0.0665 0.2196
vn -0.8395 0.0665 0.5392
vn -0.6045 0.0665 0.7939
vn 0.0181 -0.0665 0.9976
vn -0.9856 -0.0665 -0.1555
vn -0.9793 -0.0665 0.1910
vn -0.8549 -0.0665 0.5145
vn -0.6274 -0.0665 0.7758
vn -0.3242 -0.0665 0.9436
vt 0.187500 0.916667
vt 0.156250 1.000000
vt 0.156250 0.916667
vt 0.187500 0.500000
vt 0.156250 0.583333
vt 0.156250 0.500000
vt 0.187500 0.583333
vt 0.156250 0.666667
vt 0.187500 0.666667
vt 0.156250 0.750000
vt 0.187500 0.750000
vt 0.156250 0.833333
vt 0.187500 0.833333
vt 0.187500 1.000000
s 0
usemtl #73E1E7
f 1/4/2 14/5/2 3/6/2
f 8/9/4 12/10/4 13/8/4
f 6/13/6 10/3/6 11/12/6
f 1/4/8 9/7/8 14/5/8
f 8/9/10 7/11/10 12/10/10
f 6/13/12 5/1/12 10/3/12
usemtl #50BEEF
f 5/1/1 4/2/1 10/3/1
f 9/7/3 13/8/3 14/5/3
f 7/11/5 11/12/5 12/10/5
f 5/1/7 2/14/7 4/2/7
f 9/7/9 8/9/9 13/8/9
f 7/11/11 6/13/11 11/12/11
`)));

    </script>
</body>

</html>
